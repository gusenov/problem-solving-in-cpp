#include <iostream>
#include <iomanip>
#include <limits>
#include <cstdlib>
#include <ctime>
#include <windows.h>

// Переход на кириллицу:
void cyrillic() {
	// Эти строки нужны для правильного отображения кириллицы:
	SetConsoleOutputCP(1251);
	SetConsoleCP(1251);
	
	// Также надо изменить шрифт в консоли на Lucida Console.
	// Для замены шрифта кликаете правой кнопкой на надписи «Командная строка» окна консоли. 
	// В открывшемся меню выбираете «Свойства». 
	// В появившемся окне выбираете вкладку «Шрифт» и там выбираете «Lucida Console». 
}

int main(int argc, char** argv) {
	int i, j;  // счетчики.
	
	int max;  // индекс максимального элемента в исходном массиве.
	float t;  // временная переменная для обмена значениями.
	
	int n;  // размер исходного массива.
	float *a;  // указатель на исходный одномерный динамический массив.
	float *b;  // указатель на отсортированный массив.
	
	cyrillic();
	
	std::cout << "Введите с клавиатуры размер массива: ";
	std::cin >> n;
	
	// Выделение памяти под одномерный динамический массив a[n]:
	a = new float[n];
	if (a == 0) {  // если не удалось выделить память:
		std::cout << "Не удалось выделить память" << std::endl;
		return 1;  // выход по ошибке, код ошибки 1.
	}

	std::cout << "Исходный массив: " << std::endl;
	srand(time(0));  // автоматическая рандомизация генератора случайных чисел (чтобы всегда получать разные случайные числа).
	for (i = 0; i < n; i++) {
		*(a + i) = static_cast<float>(rand()) / static_cast<float>(RAND_MAX);  // генерация случайного вещественного числа в диапазоне [0; 1].
		
		// Генерация знака для числа:
		if (rand() % 2 == 0) {  // генерируем случайное целое число в диапазоне [0; 1] и если выпало 0, то меняем знак на минус:
			*(a + i) = - *(a + i);
		}
		
		// Вывод исходного массива:
		std::cout << std::fixed << std::setprecision(2) << *(a + i) << " ";  // вывод вещественного числа с точностью до 2 чисел после запятой.
	}
	std::cout << std::endl;
	
	// Выделение памяти под отсортированный массив b[n], содержащий отсортированные числа массива a:
	b = new float[n];
	if (b == 0) {  // если не удалось выделить память:
		std::cout << "Не удалось выделить память" << std::endl;
		return 1;  // выход по ошибке, код ошибки 1.
	}
	
	// Копирование исходного массива:
	for (i = 0; i < n; i++) {
		*(b + i) = *(a + i);  // копируем значение соответствующего элемента массива.
	}
	
	// Получение отсортированного массива b[n]:
	for (i = n - 1; i >= 0; i--) {  // каждый шаг конец массива i сдвигается на один элемент влево.
		
		// Находим максимальный элемент в массиве:
		max = 0;
		for (j = 0; j <= i; j++) {
			if (*(b + j) >= *(b + max)) {
				max = j;
			}
		}
		
		// И перемещаем его в конец массива.
		t = *(b + i);
		*(b + i) = *(b + max);
		*(b + max) = t;
	}
	
	delete[] a;  // освобождение памяти.
	a = 0;
	
	// Вывод отсортированного массива b[n]:
	std::cout << "Отсортированный массив: " << std::endl;
	for (i = 0; i < n; i++) {
		std::cout << std::fixed << std::setprecision(2) << *(b + i) << " ";  // вывод вещественного числа с точностью до 2 чисел после запятой.
	}
	std::cout << std::endl;
	
	delete[] b;  // освобождение памяти.
	b = 0;
	
	system("pause");
	
	return 0;
}


