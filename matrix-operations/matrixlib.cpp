#include <iostream>
#include <cstdio>
#include "matrixlib.hpp"

using namespace std;

// Конструктор, заполняет матрицу значением v:
Matrix::Matrix(unsigned y, unsigned x, double v) {
	printf("ОТЛАДКА. Вызов конструктора для объекта по адресу: '%p'.\n", this);
	
	unsigned asize = x * y;
	
	Array = new double[asize];	
	if (!Array) {
		cerr << "Memory allocation error";
		exit(1);
	}
	
	xsize = x;
	ysize = y;
    
	temporary = 0;  // все объекты класса Matrix создаются как "постоянные".
    // Методы класса при необходимости должны сами изменять эту переменную для "временных" объектов.
    
  	for (int i = 0; i < asize; i++)
	  Array[i] = v;
}

// Конструктор копирования создает копию объекта, переданного ему в качестве параметра:
Matrix::Matrix(Matrix & M) {
	printf("ОТЛАДКА. Вызов конструктора копирования для объекта по адресу: '%p'.\n", this);
	
	xsize = M.xsize;
	ysize = M.ysize;
	
	temporary = 0;  // все объекты класса Matrix создаются как "постоянные".
	// Методы класса при необходимости должны сами изменять эту переменную для "временных" объектов.
	
	if (M.temporary) {  // если объект "временный":
		Array = M.Array;  // указатель Array копии настраивается на уже имеющийся динамический массив.
		M.Array = NULL;  // указатель  Array "оригинала" обнуляется (обнуление указателя объекта-параметра необходимо для корректной работы деструктора).
		delete &M;  // и сам "оригинал" удаляется.
	
	} else {  // если объект не "временный":
		
		// В динамической памяти создается массив -  копия, на которую настраивается указатель  Array:
		unsigned asize = xsize * ysize;
		Array = new double[asize];
		
		if (!Array) {
			cerr << "Memory allocation error";
			exit(1);
		}
		
		for(int i = 0; i < asize; i++)
			Array[i] = M.Array[i];
	}
}

// Деструктор:
Matrix::~Matrix() {
	printf("ОТЛАДКА. Вызов деструктора для объекта по адресу: '%p'.\n", this);
	
	// Деструктор класса освобождает память, выделенную под динамический массив, 
	// если только этот массив не перешел в пользование другому объекту и указатель Array не был обнулен:
	if (Array)
		delete [] Array;
}

// "Примитивный" вывод:
void Matrix::show(void) {
	cout << '\n';
	for (int i = 0; i < ysize; i++) {
		for (int j = 0; j < xsize; j++)
			cout << Array[i * xsize + j] << '\t';
		cout << '\n';
	}
	if (temporary)
		delete this;
}

// Перегруженный оператор "()" с одним операндом целого типа 
// позволяет получить доступ к элементу матрицы по его индексу в последовательной системе индексации:
double & Matrix::operator()(unsigned n) const {
   if (n > xsize * ysize) {  // при выходе за границу массива:
	   cerr << "Index exceeds matrix dimensions!";  // формируется сообщение об ошибке.
	   exit(1);  // и программа аварийно завершается.
   }
   
   // Операция не разрешена для "временных" объектов, 
   // так как по определению "временные" объекты должны быть уничтожены после использования, 
   // и, следовательно, недопустимо ссылаться на их элементы:
   if (temporary) {
	   cerr << "Missing operator!";
	   exit(1);
   }
   
   // Результат операции - ссылка на элемент.
   // Поэтому с помощью операции можно не только считывать, но и изменять элементы матрицы, присваивая им новые значения.
   return Array[n - 1];  // элементы нумеруются "обычным" порядком (начиная с 1).
}
	
// Возвратить размеры матрицы:

unsigned Matrix::getxsize(void) {
	return xsize;
}

unsigned Matrix::getysize(void) {
	return ysize;
}

